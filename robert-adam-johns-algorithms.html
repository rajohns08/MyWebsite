<!DOCTYPE html>
<html>
	<head>
		<meta name="description" content="Adam Johns personal website for his software projects such as remindertimer, rapid count, and bookmarkdownloader">
		<title>Algorithms: Robert Adam Johns</title>
		<link rel="stylesheet" type="text/css" href="css/index.css">
	</head>
	<body>
		<h1 id="banner">robert<p>adam</p>johns</h1>
		<ul id="mainNavBar">
			<li><a href="index.html">home</a></li>
			<li><a href="robert-adam-johns-about.html">about</a></li>
			<li><a href="robert-adam-johns-projects.html">projects</a></li>
			<li><a href="robert-adam-johns-algorithms.html" class="on">algorithms</a></li>
			<li><a href="http://robertadamjohns.blogspot.com">blog</a></li>
			<li><a href="robert-adam-johns-contact.html">contact</a></li>
		</ul>
		<h1 class="bodyHeaders">binary<p>search</p></h1>
		<ul class="bodyHeaderLinks">
			<li><a href="">my c++ implementation</a></li>
		</ul>
		<p class="rootParagraph">
			Binary search is a search algorithm for searching for a value in an array type structure of data. This search algorithm requires that the list of data already be in a sorted order, because that is the key behind the time complexity of the algorithm. The algorithm uses the size of the list, and the list itself to start searching the list for the given value. The algorithm first checks the middle element of the list to see if it is the value. If the middle element is greater than the element you are searching for, you know that the element you are searching for must be in the first half of the list. Thus you can discard the latter half of the list. This method of searching a list allows you to discard half of the remaining list every time you check for the value. This halving of the list after every search results in a O(logn) running time complexity, which is great for value searching algorithms.
		</p>
		<hr>
		<h1 class="bodyHeaders">breadth<p>first</p>search</h1>
		<ul class="bodyHeaderLinks">
			<li><a href="">my c++ implementation</a></li>
		</ul>
		<p class="rootParagraph">
			Breadth First Search is an algorithm for searching a graph or a tree type data structure. If you imagine that the root node of the graph is depth k, then the nodes at depth k+1 would be every node that is directly attached to the root node. Likewise, the nodes at depth k+2 would be every node directly attached to a node at depth k+1 and so on. The algorithm searches the tree or graph in "level" order. Level order means that the algorithm will explore every node at depth k+1, before it moves to depth k+2. The algorithm uses a queue data structure to push on nodes to visit, and pop them off in a FIFO manner to retain the level ordering.
		</p>
		<hr>
		<h1 class="bodyHeaders">depth<p>first</p>search</h1>
		<ul class="bodyHeaderLinks">
			<li><a href="">my c++ implementation</a></li>
		</ul>
		<p class="rootParagraph">
			Depth First Search is an algorithm for searching a tree or graph type data structure. The algorithm searches the tree or graph all the way down to the deepest level node before returning to the top depth, to search down the next branch. Depth First Search uses a stack data structure as opposed to the queue data structure of breadth first search. The stack data structure is used to preserve depth searching by operating in a LIFO fashion. When a child node is pushed onto the stack, the function can be called again recursively with the top of the stack to ensure depth first searching. Depth first searching has 3 popular styles for binary trees: preorder, inorder, and postorder. Preorder processes a node as soon as it comes to the node, and then recursively searches left and right children. Inorder processes a node if there are no more left children of the node, then will check for right children. Postorder processes a node only after there are no left or right children.
		</p>
		<hr>
		<h1 class="bodyHeaders">merge<p>sort</p></h1>
		<ul class="bodyHeaderLinks">
			<li><a href="">my c++ implementation</a></li>
		</ul>
		<p class="rootParagraph">
			Merge sort is an algorithm for sorting an array type data structure. This algorithm works by breaking up an array/list (usually recursively), into a left half and a right half. The algorithm repeats this fragmentation until there is only 1 item remaining in n separate lists (where n is the number of elements in the original array). Once there is only one item remaining in each list, it is already sorted, so you merge each item with a paired item in the first merge step. The merging step consists of moving each element of the left and right halves into a new array in sorted order. Once the first merge step completes, you have multiple lists of 2 items. You then merge lists of 2 together, then 4 and so on until you have merged all the elements back into a single sorted list. Merge sort has O(nlogn) running time. Merge sort is often compared to quick sort, and one advantage merge sort has is that its worst case time complexity is O(nlogn), whereas worst case time complexity of quick sort is O(n<sup>2</sup>).
		</p>
		<hr>
		<h1 class="bodyHeaders">stack</h1>
		<ul class="bodyHeaderLinks">
			<li><a href="">my c++ implementation</a></li>
		</ul>
		<p class="rootParagraph">
			A stack is a data structure that operates in a last in first out (LIFO) fashion. Stacks have 2 main operations: push and pop. When an element is pushed onto the stack it is added to the end of the stack. When an element is popped off of the stack, it is removed from the end of the stack. This means that elements are removed from a stack in the reverse order that they are added to the stack. For example, if you push on 5 different elements, and then perform a pop operation, the last element that was added will be the element that is removed from the stack.
		</p>
		<hr>
		<h1 class="bodyHeaders">linked<p>list</p></h1>
		<ul class="bodyHeaderLinks">
			<li><a href="">my c++ implementation</a></li>
		</ul>
		<p class="rootParagraph">
			A linked list is a data structure that contains nodes that are connected to at least one other node sequentially by a pointer. Each node may contain multiple attributes of data such as a string and an int. There are 3 main types of linked list implementations: singly, doubly, and circular. In a singly linked list, each node has one pointer to the next node in the list, and the last node in the list points to NULL. In a doubly linked list, each node has a pointer to the next node in the list, and the previous node in the list. A circular linked list is very similar to a singly linked list, with the condition that the last node in the list point to the root node instead of to NULL. A linked list is useful because the size of the structure does not have to be known at compile time. The structure can grow or shrink in size as needed, much like a vector. An advantage that a linked list has over a vector is that the insertion and deletion of a node can be done in constant time, since each node is connected via pointers. 
		</p>
		<hr>
		<h1 class="bodyHeaders">binary<p>tree</p></h1>
		<ul class="bodyHeaderLinks">
			<li><a href="">my c++ implementation</a></li>
		</ul>
		<p class="rootParagraph">
			A binary tree is a non-sequential data structure in which every node in the structure has at most 2 children. The structure is non-sequential because the nodes are not linked together in a linear chain as in a linked list. Every node except for the root node has exactly one predecessor or parent. A binary tree can be useful for searching large sets of data, because of the way the child nodes are arranged. The child nodes are arranged in a manner where the left child of a node has a lesser value than the parent node, and the right child has a greater value. A node that has no children is called a leaf node, and it is the deepest node for a given branch. When a node is inserted into a binary tree, it is always inserted as a leaf node, thus the shape of the tree is dependent upon the order of insertion. Traversing a binary tree is typically accomplished using Preorder, Inorder, or Postorder traversals as explained under depth first search.
		</p>
		<hr>
		<h1 class="bodyHeaders">trie</h1>
		<ul class="bodyHeaderLinks">
			<li><a href="">my c++ implementation</a></li>
		</ul>
		<p class="rootParagraph">
			A trie is a data structure that represents sets of character strings. Each node in the structure typically contains 26 pointers (one for each letter of the alphabet). The structure is usually organized in a tree type data structure. The time complexity for searching whether or not a word exists in the structure is O(n) (proportional to the length of the word). Space complexity of the structure is proportional to the number of characters in the entire document in the worst case. For example, if you have a trie with 10 words, each starting with a different letter, then there will be an individual node for each character in the data. One common application of a trie is word matching, since the trie data structure has such good time complexity for searching for a word. When storing a word to a trie from an input file, you should also keep track of where each word occurs, in case it occurs more than once. The space complexity problem of a trie can be solved by compressing nodes with only one child node. Nodes with only one child node can be combined into the parent node to save space. Another common application of the trie data structure is for routers in router lookup tables for finding the best possible match to where to send out a packet given an IP address. 
		</p>
		<hr>
		<h1 class="bodyHeaders">singleton<p>design</p>pattern</h1>
		<ul class="bodyHeaderLinks">
			<li><a href="">my java implementation</a></li>
		</ul>
		<p class="rootParagraph">
			The singleton design pattern is a design pattern that is used in an environment in which the programmer only wants to allow a single instantiation of an object for a given class. This pattern is usually accomplished through making a private constructor, and providing a getInstance method for the class. The private constructor will prevent an object from being instantiated in the traditional sense, and the getInstance method will handle the control of handing out objects. The getInstance method will only return a new object if one has not already been created (in a lazy instantiation). A lazy instantiation is one that only creates an object when one is asked for. This method is good for preserving space if needed, but it can introduce some problems also. For example, if 2 threads enter the getInstance method at the same time, then there will be 2 separate objects returned. To prevent this thread synchronization problem, you can swap to an eager instantiation and automatically instantiate an object, or you can make the getInstance method synchronized in Java, so that only one thread can enter it at a time. There are also other methods of solving the thread synchronization problem, but the 2 previously mentioned are the simplest from a coding perspective. 
		</p>
		<hr>
	</body>
	<footer>
		&copy;2013 robertadamjohns
	</footer>
</html>